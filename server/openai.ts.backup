import OpenAI from "openai";
import * as mammoth from "mammoth";
import * as fs from "fs";
import * as path from "path";
import { 
  selectGreetingTemplate, 
  selectTransitionTemplate, 
  buildDynamicSystemPrompt,
  analyzeResponseSimilarity,
  generateAlternativeResponse,
  cleanupResponse 
} from "./chatTemplates";

// ì „ê³µë³„ ì°¨ë³„í™”ëœ temperature ì„¤ì •
function getAgentTemperature(agentName: string, agentDescription: string): number {
  const lowerName = agentName.toLowerCase();
  const lowerDesc = agentDescription.toLowerCase();
  
  // MSE (ì¬ë£Œê³µí•™) - ì‹ ì¤‘í•˜ê³  ì •í™•í•¨
  if (lowerName.includes('mse') || lowerDesc.includes('ì¬ë£Œ') || lowerDesc.includes('ì†Œì¬')) {
    return 0.6;
  }
  // CSE (ì»´í“¨í„°ê³µí•™) - ë…¼ë¦¬ì ì´ê³  í™œë°œí•¨  
  if (lowerName.includes('cse') || lowerDesc.includes('ì»´í“¨í„°') || lowerDesc.includes('í”„ë¡œê·¸ë˜ë°')) {
    return 0.9;
  }
  // EE (ì „ê¸°ì „ì) - ì²´ê³„ì ì´ê³  ì•ˆì •ì 
  if (lowerName.includes('ee') || lowerDesc.includes('ì „ê¸°') || lowerDesc.includes('ì „ì')) {
    return 0.7;
  }
  // ìƒëª…ê³¼í•™ - íƒêµ¬ì ì´ê³  ìœ ì—°í•¨
  if (lowerDesc.includes('ìƒëª…') || lowerDesc.includes('ë°”ì´ì˜¤') || lowerDesc.includes('ìƒë¬¼')) {
    return 0.85;
  }
  // í™”í•™ - ì •ë°€í•˜ê³  ì²´ê³„ì 
  if (lowerDesc.includes('í™”í•™')) {
    return 0.65;
  }
  // ë¬¼ë¦¬ - ë…¼ë¦¬ì ì´ê³  ì›ë¦¬ ì¤‘ì‹¬
  if (lowerDesc.includes('ë¬¼ë¦¬')) {
    return 0.75;
  }
  // ê²½ì˜ - ì‹¤ìš©ì ì´ê³  ìœ ì—°í•¨
  if (lowerDesc.includes('ê²½ì˜') || lowerDesc.includes('ë¹„ì¦ˆë‹ˆìŠ¤')) {
    return 0.8;
  }
  // êµìœ¡ - ì¹œê·¼í•˜ê³  ì†Œí†µ ì¤‘ì‹¬
  if (lowerDesc.includes('êµìœ¡')) {
    return 0.85;
  }
  
  // ê¸°ë³¸ê°’
  return 0.8;
}

// ê¸°ê´€ëª… ìë™ êµì • í•¨ìˆ˜
function correctInstitutionNames(response: string): string {
  return response
    .replace(/ì…í•™ì²˜/g, 'êµë¬´ì²˜ í•™ì‚¬íŒ€')
    .replace(/SNS\s*ë“±?/g, 'í•™ì‚¬ê³µì§€/í•™ì‚¬ìš”ëŒ')
    .replace(/ì…í•™ì²˜[\s]*[\,\.]?[\s]*SNS/g, 'êµë¬´ì²˜ í•™ì‚¬íŒ€, í•™ì‚¬ê³µì§€');
}

// ì™„ê²°ì„± ê²€ì‚¬ í•¨ìˆ˜ (ìì—°ìŠ¤ëŸ¬ìš´ ë¬¸ì¥ ì¢…ë£Œ í™•ì¸)
function checkCompletenessGuard(response: string): boolean {
  // ë„ˆë¬´ ì§§ê±°ë‚˜ ëª…ë°±íˆ ì¤‘ê°„ì— ëŠì–´ì§„ ì‘ë‹µë§Œ ì²´í¬
  const isTooShort = response.trim().length < 20;
  const endsAbruptly = response.match(/[ê°€-í£a-zA-Z]$/m); // ë¬¸ìë¡œ ëë‚˜ëŠ” ê²½ìš° (ë¯¸ì™„ì„±)
  const hasStrangeEnding = response.match(/(ë”°ë¥¸ì¡°|í•˜ëŠ”ë°ì—|ì´ì—ìš”ìš”|ë‹ˆë‹¤ë‹¤|í•´ìš”ìš”|ì£ ì£ |ë„¤ë„¤|ì–´ìš”ìš”)$/);
  
  return !isTooShort && !endsAbruptly && !hasStrangeEnding;
}

// the newest OpenAI model is "gpt-4o" which was released May 13, 2024. do not change this unless explicitly requested by the user
const openai = new OpenAI({ 
  apiKey: process.env.OPENAI_API_KEY || process.env.OPENAI_KEY || ""
});

export interface ChatResponse {
  message: string;
  usedDocuments?: string[];
  triggerAction?: string;
}

export interface DocumentAnalysis {
  summary: string;
  keyPoints: string[];
  extractedText: string;
}

export async function analyzeDocument(content: string, filename: string): Promise<DocumentAnalysis> {
  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "system",
          content: "ë‹¹ì‹ ì€ ë¬¸ì„œ ë¶„ì„ ì „ë¬¸ê°€ì…ë‹ˆë‹¤. ì£¼ì–´ì§„ ë¬¸ì„œë¥¼ ë¶„ì„í•˜ì—¬ ìš”ì•½, ì£¼ìš” í¬ì¸íŠ¸, ì „ì²´ í…ìŠ¤íŠ¸ë¥¼ ì¶”ì¶œí•˜ì„¸ìš”. ì‘ë‹µì€ JSON í˜•ì‹ìœ¼ë¡œ í•´ì£¼ì„¸ìš”.",
        },
        {
          role: "user",
          content: `ë‹¤ìŒ ë¬¸ì„œë¥¼ ë¶„ì„í•´ì£¼ì„¸ìš”. íŒŒì¼ëª…: ${filename}\n\në‚´ìš©:\n${content}`,
        },
      ],
      response_format: { type: "json_object" },
    });

    const result = JSON.parse(response.choices[0].message.content || "{}");
    
    return {
      summary: result.summary || "ë¬¸ì„œ ìš”ì•½ì´ ìƒì„±ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.",
      keyPoints: result.keyPoints || [],
      extractedText: content,
    };
  } catch (error) {
    console.error("Document analysis failed:", error);
    return {
      summary: "ë¬¸ì„œ ë¶„ì„ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
      keyPoints: [],
      extractedText: content,
    };
  }
}

export async function generateManagementResponse(
  userMessage: string,
  agentName: string,
  agentDescription: string,
  conversationHistory: Array<{ role: "user" | "assistant"; content: string }>,
  availableDocuments: Array<{ filename: string; content: string }>,
  chatbotType: string = "general-llm",
  speechStyle: string = "ì¹œê·¼í•˜ê³  ë„ì›€ì´ ë˜ëŠ” ë§íˆ¬",
  personality: string = "ì¹œì ˆí•˜ê³  ì „ë¬¸ì ì¸ ì„±ê²©ìœ¼ë¡œ ì •í™•í•œ ì •ë³´ë¥¼ ì œê³µ",
  additionalPrompt: string = "",
  userLanguage: string = "ko",
  conversationId?: number
): Promise<ChatResponse> {
  // Check if we need to translate Korean text to English
  if (userLanguage === "en" && containsKorean(userMessage)) {
    console.log("Korean text detected in English mode (management), translating...");
    userMessage = await translateKoreanToEnglish(userMessage);
    console.log("Translated management message:", userMessage);
  }

  const lowerMessage = userMessage.toLowerCase();
  
  // Check for management commands with typo tolerance
  if (lowerMessage.includes("í˜ë¥´ì†Œë‚˜") || lowerMessage.includes("persona") || lowerMessage.includes("ì„±ê²©") || 
      lowerMessage.includes("ë§íˆ¬") || lowerMessage.includes("ìºë¦­í„°") || lowerMessage.includes("ê°œì„±") ||
      lowerMessage.includes("ë‹‰ë„¤ì„") || lowerMessage.includes("íŠ¹ì„±") || lowerMessage.includes("ë³€ê²½") ||
      lowerMessage.includes("ìˆ˜ì •") || lowerMessage.includes("í¸ì§‘")) {
    const personaMessage = userLanguage === "en" 
      ? "ğŸ”§ Persona editing window opened. You can modify nickname, speaking style, knowledge domain, personality traits, and prohibited word response."
      : "ğŸ”§ í˜ë¥´ì†Œë‚˜ í¸ì§‘ ì°½ì„ ì—´ì—ˆìŠµë‹ˆë‹¤. ë‹‰ë„¤ì„, ë§íˆ¬ ìŠ¤íƒ€ì¼, ì§€ì‹ ë¶„ì•¼, ì„±ê²© íŠ¹ì„±, ê¸ˆì¹™ì–´ ë°˜ì‘ ë°©ì‹ì„ ìˆ˜ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.";
    return {
      message: personaMessage,
      usedDocuments: [],
      triggerAction: "openPersonaModal"
    };
  }
  
  if (lowerMessage.includes("ì±—ë´‡") || lowerMessage.includes("ì„¤ì •") || lowerMessage.includes("ëª¨ë¸") ||
      lowerMessage.includes("llm") || lowerMessage.includes("gpt") || lowerMessage.includes("aiì„¤ì •") ||
      lowerMessage.includes("ë´‡ì„¤ì •") || lowerMessage.includes("ë™ì‘") || lowerMessage.includes("ìœ í˜•")) {
    const settingsMessage = userLanguage === "en" 
      ? "ğŸ”§ Chatbot settings window opened. You can change LLM model and chatbot type."
      : "ğŸ”§ ì±—ë´‡ ì„¤ì • ì°½ì„ ì—´ì—ˆìŠµë‹ˆë‹¤. LLM ëª¨ë¸ê³¼ ì±—ë´‡ ìœ í˜•ì„ ë³€ê²½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.";
    return {
      message: settingsMessage,
      usedDocuments: [],
      triggerAction: "openSettingsModal"
    };
  }
  
  if (lowerMessage.includes("ë¬¸ì„œ") || lowerMessage.includes("ì—…ë¡œë“œ") || lowerMessage.includes("íŒŒì¼") ||
      lowerMessage.includes("ìë£Œ") || lowerMessage.includes("ì²¨ë¶€") || lowerMessage.includes("ì§€ì‹") ||
      lowerMessage.includes("í•™ìŠµ") || lowerMessage.includes("ë°ì´í„°") || lowerMessage.includes("ì •ë³´")) {
    const fileMessage = userLanguage === "en" 
      ? "ğŸ”§ Document upload window opened. You can upload TXT, DOC, DOCX, PPT, PPTX format documents to expand the agent's knowledge base."
      : "ğŸ”§ ë¬¸ì„œ ì—…ë¡œë“œ ì°½ì„ ì—´ì—ˆìŠµë‹ˆë‹¤. TXT, DOC, DOCX, PPT, PPTX í˜•ì‹ì˜ ë¬¸ì„œë¥¼ ì—…ë¡œë“œí•˜ì—¬ ì—ì´ì „íŠ¸ì˜ ì§€ì‹ë² ì´ìŠ¤ë¥¼ í™•ì¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.";
    return {
      message: fileMessage,
      usedDocuments: [],
      triggerAction: "openFileModal"
    };
  }
  
  if (lowerMessage.includes("ì•Œë¦¼") || lowerMessage.includes("notification") || lowerMessage.includes("ë¸Œë¡œë“œìºìŠ¤íŠ¸") ||
      lowerMessage.includes("ê³µì§€") || lowerMessage.includes("ë©”ì‹œì§€") || lowerMessage.includes("ì „ì†¡") ||
      lowerMessage.includes("ì•ˆë‚´") || lowerMessage.includes("ì†Œì‹")) {
    const notificationMessage = userLanguage === "en" 
      ? "ğŸ”§ Notification function started. Enter notification content. It will be sent to all users."
      : "ğŸ”§ ì•Œë¦¼ ê¸°ëŠ¥ì„ ì‹œì‘í•©ë‹ˆë‹¤. ì•Œë¦¼ ë‚´ìš©ì„ ì…ë ¥í•˜ì„¸ìš”. ëª¨ë“  ì‚¬ìš©ìì—ê²Œ ì „ì†¡ë©ë‹ˆë‹¤.";
    return {
      message: notificationMessage,
      usedDocuments: [],
      triggerAction: "startNotification"
    };
  }
  
  if (lowerMessage.includes("ë„ì›€ë§") || lowerMessage.includes("ëª…ë ¹ì–´") || lowerMessage.includes("ê¸°ëŠ¥") || 
      lowerMessage.includes("help") || lowerMessage.includes("ì‚¬ìš©ë²•") || lowerMessage.includes("ë©”ë‰´") ||
      lowerMessage.includes("ì˜µì…˜") || lowerMessage.includes("ê°€ì´ë“œ")) {
    const helpMessage = userLanguage === "en" 
      ? `ğŸ”§ Agent Management Commands:

ğŸ“ Main Features:
â€¢ "persona" / "personality" / "style" - Set agent personality and speaking style
â€¢ "chatbot settings" / "model" / "AI settings" - Change LLM model and operation mode
â€¢ "document upload" / "file" / "data" - Add documents to expand knowledge base
â€¢ "notification" / "announcement" / "message" - Send announcements to users
â€¢ "performance analysis" / "statistics" / "status" - View agent usage statistics and analysis

ğŸ’¡ Usage: Send a message containing the above keywords to execute the function.
General conversation is also always possible!`
      : `ğŸ”§ ì—ì´ì „íŠ¸ ê´€ë¦¬ ëª…ë ¹ì–´:

ğŸ“ ì£¼ìš” ê¸°ëŠ¥:
â€¢ "í˜ë¥´ì†Œë‚˜" / "ì„±ê²©" / "ë§íˆ¬" - ì—ì´ì „íŠ¸ ì„±ê²© ë° ë§íˆ¬ ì„¤ì •
â€¢ "ì±—ë´‡ ì„¤ì •" / "ëª¨ë¸" / "AIì„¤ì •" - LLM ëª¨ë¸ ë° ë™ì‘ ë°©ì‹ ë³€ê²½  
â€¢ "ë¬¸ì„œ ì—…ë¡œë“œ" / "íŒŒì¼" / "ìë£Œ" - ì§€ì‹ë² ì´ìŠ¤ í™•ì¥ìš© ë¬¸ì„œ ì¶”ê°€
â€¢ "ì•Œë¦¼ë³´ë‚´ê¸°" / "ê³µì§€" / "ë©”ì‹œì§€" - ì‚¬ìš©ìë“¤ì—ê²Œ ê³µì§€ì‚¬í•­ ì „ì†¡
â€¢ "ì„±ê³¼ ë¶„ì„" / "í†µê³„" / "í˜„í™©" - ì—ì´ì „íŠ¸ ì‚¬ìš© í†µê³„ ë° ë¶„ì„

ğŸ’¡ ì‚¬ìš©ë²•: ìœ„ í‚¤ì›Œë“œê°€ í¬í•¨ëœ ë©”ì‹œì§€ë¥¼ ë³´ë‚´ë©´ í•´ë‹¹ ê¸°ëŠ¥ì´ ì‹¤í–‰ë©ë‹ˆë‹¤.
ì¼ë°˜ ëŒ€í™”ë„ ì–¸ì œë“  ê°€ëŠ¥í•©ë‹ˆë‹¤!`;
    return {
      message: helpMessage,
      usedDocuments: []
    };
  }
  
  // For regular messages in management mode, use normal chat response
  return generateChatResponse(
    userMessage,
    agentName,
    agentDescription,
    conversationHistory,
    availableDocuments,
    chatbotType,
    speechStyle,
    personality,
    additionalPrompt,
    userLanguage,
    conversationId
  );
}

// Function to detect Korean text
function containsKorean(text: string): boolean {
  const koreanRegex = /[\u3131-\u318E\u3200-\u321E\u3260-\u327E\uAC00-\uD7A3]/;
  return koreanRegex.test(text);
}

// Function to translate Korean text to English
async function translateKoreanToEnglish(text: string): Promise<string> {
  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "system",
          content: "You are a professional Korean to English translator. Translate the given Korean text to natural, fluent English. Only return the translated text without any additional comments or explanations."
        },
        {
          role: "user",
          content: text
        }
      ],
      max_tokens: 1000,
      temperature: 0.1,
    });

    return response.choices[0].message.content || text;
  } catch (error) {
    console.error("Translation failed:", error);
    return text; // Return original text if translation fails
  }
}

export async function generateChatResponse(
  userMessage: string,
  agentName: string,
  agentDescription: string,
  conversationHistory: Array<{ role: "user" | "assistant"; content: string }>,
  availableDocuments: Array<{ filename: string; content: string }> = [],
  chatbotType: string = "general-llm",
  speechStyle: string = "ì¹œê·¼í•˜ê³  ë„ì›€ì´ ë˜ëŠ” ë§íˆ¬",
  personality: string = "ì¹œì ˆí•˜ê³  ì „ë¬¸ì ì¸ ì„±ê²©ìœ¼ë¡œ ì •í™•í•œ ì •ë³´ë¥¼ ì œê³µ",
  additionalPrompt: string = "",
  userLanguage: string = "ko",
  conversationId?: number
): Promise<ChatResponse> {
  try {
    // Debug log to check if persona parameters are received
    console.log("OpenAI persona parameters:", {
      speechStyle,
      personality,
      chatbotType
    });

    // Check if we need to translate Korean text to English
    if (userLanguage === "en" && containsKorean(userMessage)) {
      console.log("Korean text detected in English mode, translating...");
      userMessage = await translateKoreanToEnglish(userMessage);
      console.log("Translated message:", userMessage);
    }

    // Translate agent name and description to English if needed
    if (userLanguage === "en") {
      if (containsKorean(agentName)) {
        agentName = await translateKoreanToEnglish(agentName);
      }
      if (containsKorean(agentDescription)) {
        agentDescription = await translateKoreanToEnglish(agentDescription);
      }
      if (containsKorean(speechStyle)) {
        speechStyle = await translateKoreanToEnglish(speechStyle);
      }
      if (containsKorean(personality)) {
        personality = await translateKoreanToEnglish(personality);
      }
    }

    // Translate conversation history to English if needed
    if (userLanguage === "en") {
      for (let i = 0; i < conversationHistory.length; i++) {
        if (containsKorean(conversationHistory[i].content)) {
          conversationHistory[i].content = await translateKoreanToEnglish(conversationHistory[i].content);
        }
      }
    }

    // Prepare context from documents with enhanced processing
    let documentContext = "";
    if (availableDocuments.length > 0) {
      if (userLanguage === "en") {
        // Translate Korean document content to English
        const translatedDocs = [];
        for (const doc of availableDocuments) {
          let translatedContent = doc.content;
          if (containsKorean(doc.content)) {
            translatedContent = await translateKoreanToEnglish(doc.content);
          }
          translatedDocs.push({
            filename: doc.filename,
            content: translatedContent
          });
        }
        documentContext = `\n\nReference Documents:\n${translatedDocs.map(doc => 
          `[Document: ${doc.filename}]\n${doc.content}`
        ).join('\n\n')}`;
      } else {
        documentContext = `\n\nì°¸ê³  ë¬¸ì„œ:\n${availableDocuments.map(doc => 
          `[ë¬¸ì„œëª…: ${doc.filename}]\n${doc.content}`
        ).join('\n\n')}`;
      }
    }

    // Enhanced document analysis for better responses
    const hasDocumentQuestion = userMessage.includes("ë¬¸ì„œ") || userMessage.includes("ë‚´ìš©") || 
                               userMessage.includes("ì„¸ê³„ê´€") || userMessage.includes("íŒŒì¼") ||
                               availableDocuments.some(doc => 
                                 userMessage.includes(doc.filename.replace('.docx', '').replace('.pdf', ''))
                               );

    // Language mapping for responses
    const languageInstructions = {
      'ko': 'í•œêµ­ì–´ë¡œ ì‘ë‹µí•˜ì„¸ìš”.',
      'en': 'Respond in English.',
      'zh': 'è¯·ç”¨ä¸­æ–‡å›å¤ã€‚',
      'vi': 'HÃ£y tráº£ lá»i báº±ng tiáº¿ng Viá»‡t.',
      'ja': 'æ—¥æœ¬èªã§å¿œç­”ã—ã¦ãã ã•ã„ã€‚'
    };
    
    const responseLanguage = languageInstructions[userLanguage as keyof typeof languageInstructions] || languageInstructions['ko'];
    
    // ì—ì´ì „íŠ¸ ìœ í˜• ê²°ì • (speechStyleê³¼ personality ê¸°ë°˜)
    let agentType: 'warm' | 'professional' | 'casual' | 'analytical' = 'professional';
    
    if (speechStyle.includes("ì¹œê·¼") || speechStyle.includes("ë”°ëœ»") || speechStyle.includes("ì¹œìˆ™") || 
        personality.includes("ì¹œê·¼") || personality.includes("ë”°ëœ»")) {
      agentType = 'warm';
    } else if (speechStyle.includes("ìºì£¼ì–¼") || speechStyle.includes("í¸ì•ˆ") || speechStyle.includes("ììœ ") ||
               personality.includes("ìºì£¼ì–¼") || personality.includes("í¸ì•ˆ")) {
      agentType = 'casual';
    } else if (speechStyle.includes("ë¶„ì„") || speechStyle.includes("ë…¼ë¦¬") || speechStyle.includes("ì²´ê³„") ||
               personality.includes("ë¶„ì„") || personality.includes("ë…¼ë¦¬")) {
      agentType = 'analytical';
    }

    // ì´ì „ ì‘ë‹µ ê°€ì ¸ì˜¤ê¸° (ìœ ì‚¬ë„ ê²€ì‚¬ìš©)
    const recentResponses = conversationHistory
      .filter(msg => msg.role === 'assistant')
      .slice(-3)
      .map(msg => msg.content);

    // ëŒ€í™” íšŸìˆ˜ ê³„ì‚° (ëŒ€í™” ë‹¤ì–‘ì„±ì„ ìœ„í•´)
    const conversationCount = conversationHistory.length;
    
    // ì—ì´ì „íŠ¸ë³„ ê³ ìœ ì„±ì„ ìœ„í•œ ì‹œë“œ ìƒì„± (agent name + current timestampì˜ ì¼ë¶€)
    const agentSeed = agentName.charCodeAt(0) + agentName.length + (Date.now() % 1000);
    
    // ìµœê·¼ ì±—ë´‡ ì‘ë‹µë“¤ê³¼ì˜ ìœ ì‚¬ë„ ê²€ì‚¬ë¥¼ ìœ„í•œ ì»¨í…ìŠ¤íŠ¸
    const existingResponses = recentResponses.join(' ').toLowerCase();
    
    console.log(`Generating response for ${agentName} with seed ${agentSeed}`);
    
    // ë™ì  ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ ìƒì„±
    const systemPrompt = buildDynamicSystemPrompt(
      agentName,
      agentDescription,
      speechStyle,
      personality,
      additionalPrompt,
      agentType,
      conversationCount,
      agentSeed
    );

    // ì–¸ì–´ë³„ í”„ë¡¬í”„íŠ¸ ì¶”ê°€
    const languageInstruction = `ì‘ë‹µì€ ë°˜ë“œì‹œ ${responseLanguage}`;
    
    // ìµœì¢… ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ êµ¬ì„±
    let finalSystemPrompt = "";
    
    switch (chatbotType) {
      case "strict-doc":
        if (availableDocuments.length === 0) {
          const noDocMessages = {
            'ko': "ë¬¸ì„œë¥¼ ë¨¼ì € ì—…ë¡œë“œí•´ ì£¼ì„¸ìš”. ë¬¸ì„œ ê¸°ë°˜ìœ¼ë¡œë§Œ ë‹µë³€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
            'en': "Please upload documents first. I can only answer based on documents.",
            'zh': "è¯·å…ˆä¸Šä¼ æ–‡æ¡£ã€‚æˆ‘åªèƒ½åŸºäºæ–‡æ¡£å›ç­”é—®é¢˜ã€‚",
            'vi': "Vui lÃ²ng táº£i tÃ i liá»‡u lÃªn trÆ°á»›c. TÃ´i chá»‰ cÃ³ thá»ƒ tráº£ lá»i dá»±a trÃªn tÃ i liá»‡u.",
            'ja': "ã¾ãšæ–‡æ›¸ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚æ–‡æ›¸ã«åŸºã¥ã„ã¦ã®ã¿å›ç­”ã§ãã¾ã™ã€‚"
          };
          const noDocMessage = noDocMessages[userLanguage as keyof typeof noDocMessages] || noDocMessages['ko'];
          return {
            message: noDocMessage,
            usedDocuments: []
          };
        }
        
        finalSystemPrompt = `${languageInstruction}

${systemPrompt}

DOCUMENT ANALYSIS MODE:
- Only use document content to answer questions
- Analyze documents deeply when asked about their content
- Quote relevant sections when explaining document content
- If asked about a specific document by name, focus on that document's content${documentContext}`;
        break;

      case "doc-fallback-llm":
        finalSystemPrompt = `${languageInstruction}

${systemPrompt}

DOCUMENT ANALYSIS INSTRUCTIONS:
- When documents are available, prioritize them for answers
- Analyze document content thoroughly when asked about specific documents
- Fall back to general knowledge only when documents don't contain relevant information

Rules:
- Use documents first when available, then general knowledge if needed
- Analyze documents deeply when asked about their content
- Stay true to your personality and speaking style
- Provide helpful and accurate information

CRITICAL FORMATTING RULES - ABSOLUTELY NO EXCEPTIONS:
- NEVER use ANY markdown formatting: **bold**, *italic*, __underline__, ## headers, [links], backticks
- NEVER use judgment keywords like "**ê°™ì€**", "**ë‹¤ë¥¸**", "**ë™ì˜**", "**ë°˜ëŒ€**"
- NEVER show internal decision-making processes or configuration values
- Respond ONLY with natural conversational Korean text, no formatting symbols whatsoever
- Speak as if you're having a normal conversation - no special formatting needed${documentContext}`;
        break;

      case "general-llm":
      default:
        // ì‚¬ìš©ìê°€ íŠ¹ì • êµ¬ì¡°í™”ëœ í¬ë§·ì„ ìš”ì²­í–ˆëŠ”ì§€ ê°ì§€
        const requestedStructuredFormat = userMessage.match(/["']([^"']*[:]\s*[^"']*)+["']/) || 
                                        userMessage.includes('íŒë‹¨/ê·¼ê±°') || 
                                        userMessage.includes('íŒë‹¨:') || 
                                        userMessage.includes('ê·¼ê±°:') || 
                                        userMessage.includes('ë¦¬ìŠ¤í¬:') || 
                                        userMessage.includes('ë¶„ì„:') || 
                                        userMessage.includes('ê²°ë¡ :') || 
                                        userMessage.includes('ìš”ì•½:') ||
                                        userMessage.includes('í¬ë§·ìœ¼ë¡œ') ||
                                        userMessage.includes('í˜•ì‹ìœ¼ë¡œ');
        
        // @ë©˜ì…˜ ê³¼ íŠ¹ë³„ í¬ë§· ì§€ì¹¨
        const isMentionQuestion = userMessage.includes('@');
        const mentionInstructions = isMentionQuestion ? 
          `\n\n## @ë©˜ì…˜ ì§ˆë¬¸ì— ëŒ€í•œ íŠ¹ë³„ ì§€ì¹¨:\n- ì´ê²ƒì€ @ë©˜ì…˜ ì§ˆë¬¸ì…ë‹ˆë‹¤. ì§ˆë¬¸ ë‚´ìš©ì„ ì •í™•íˆ íŒŒì•…í•˜ê³  ê·¸ì— ë§ëŠ” ì „ë¬¸ì ì¸ ë‹µë³€ì„ ì œê³µí•´ì£¼ì„¸ìš”\n- ìµœì†Œ 100ì ì´ìƒì˜ ì˜ë¯¸ ìˆëŠ” ë‹µë³€ì„ ì‘ì„±í•´ì£¼ì„¸ìš”\n- ì§ˆë¬¸ì˜ í•µì‹¬ í‚¤ì›Œë“œì™€ ë§¥ë½ì„ ë°˜ë“œì‹œ ê³ ë ¤í•˜ì—¬ ê´€ë ¨ì„± ìˆëŠ” ë‹µë³€ì„ í•´ì£¼ì„¸ìš”\n- ì „ê³µ ì§€ì‹ê³¼ ê²½í—˜ì„ ë°”íƒ•ìœ¼ë¡œ êµ¬ì²´ì ì´ê³  ì‹¤ìš©ì ì¸ ì¡°ì–¸ì„ ì œê³µí•´ì£¼ì„¸ìš”\n- ë‹¨ìˆœí•œ ì¸ì‚¬ë§ì´ë‚˜ í˜•ì‹ì ì¸ ë‹µë³€, ê´€ë ¨ ì—†ëŠ” ì£¼ì œ ì–¸ê¸‰ì„ ì ˆëŒ€ í”¼í•´ì£¼ì„¸ìš”\n- ì§ˆë¬¸ìê°€ ë¬»ê³  ìˆëŠ” êµ¬ì²´ì ì¸ ë‚´ìš©ì—ë§Œ ì§‘ì¤‘í•´ì„œ ë‹µë³€í•´ì£¼ì„¸ìš”\n` : '';
        
        const formatInstructions = requestedStructuredFormat ? 
          `\n\n## íŠ¹ë³„ ì§€ì¹¨ - ì‚¬ìš©ì ìš”ì²­ í¬ë§· ìš°ì„ :\n- ì‚¬ìš©ìê°€ íŠ¹ì • êµ¬ì¡°í™”ëœ í¬ë§·(íŒë‹¨:, ê·¼ê±°:, ë¦¬ìŠ¤í¬: ë“±)ì„ ìš”ì²­í•œ ê²½ìš°, í•´ë‹¹ í¬ë§·ì„ ì •í™•íˆ ë”°ë¼ì£¼ì„¸ìš”\n- ìš”ì²­ëœ í˜•ì‹ì— ë§ì¶° êµ¬ì¡°í™”ëœ ë‹µë³€ì„ ì œê³µí•˜ë˜, ìì—°ìŠ¤ëŸ½ê³  ìœ ìš©í•œ ë‚´ìš©ìœ¼ë¡œ ì±„ì›Œì£¼ì„¸ìš”\n- ì‚¬ìš©ìê°€ ëª…ì‹œí•œ êµ¬ì²´ì ì¸ í¬ë§·ì´ ì¼ë°˜ ëŒ€í™” ê·œì¹™ë³´ë‹¤ ìš°ì„ ë©ë‹ˆë‹¤\n` : '';
        
        finalSystemPrompt = `${languageInstruction}

${systemPrompt}${mentionInstructions}${formatInstructions}

${documentContext ? `

ì°¸ê³  ë¬¸ì„œ ì •ë³´:
${documentContext}` : ''}

## ìì—°ìŠ¤ëŸ½ê³  ê°œì„± ìˆëŠ” ì‘ë‹µ ì§€ì¹¨:
- 3-4ë¬¸ì¥ ì •ë„ì˜ ê°„ê²°í•œ ë‹µë³€ì„ ê¸°ë³¸ìœ¼ë¡œ í•˜ì„¸ìš”
- "ë„ì™€ë“œë¦´ê¹Œìš”", "ê¶ê¸ˆí•œ ì ì´ ìˆìœ¼ë©´" ê°™ì€ íšì¼ì  í‘œí˜„ ê¸ˆì§€
- ê°ìì˜ ì „ê³µ íŠ¹ì„±ì„ ì‚´ë¦° ë…íŠ¹í•œ ë§íˆ¬ì™€ ê´€ì  ì‚¬ìš©
- ê¸¸ê³  í˜•ì‹ì ì¸ ì„¤ëª…ë³´ë‹¤ëŠ” ì§§ê³  í•µì‹¬ì ì¸ ì¡°ì–¸
- ë¶ˆí™•ì‹¤í•œ ì •ë³´ëŠ” "í™•ì‹¤í•˜ì§€ ì•Šì§€ë§Œ..." ì •ë„ë¡œ ê°„ë‹¨íˆ í‘œí˜„
        break;
    }

    console.log("Final system prompt:", finalSystemPrompt);

    const messages: OpenAI.Chat.Completions.ChatCompletionMessageParam[] = [
      { role: "system", content: finalSystemPrompt },
      ...conversationHistory.slice(-10), // Keep last 10 messages for context
      { role: "user", content: userMessage },
    ];

    // Apply grumpy speaking style but still provide proper answers
    if (speechStyle && (speechStyle.includes("íˆ¬ëœì´") || speechStyle.includes("ìŠ¤ë¨¸í”„"))) {
      console.log("APPLYING GRUMPY SMURF STYLE WITH PROPER ANSWERS");
      
      const grumpyExamples = {
        'ko': {
          start: '"ì•„...", "ì—íœ´...", "í•˜..."',
          examples: [
            '"ì•„... ë˜ ê·¸ëŸ° ê±¸ ë¬¼ì–´ë³´ë„¤. [actual answer here] ì´ì œ ëì§€?"',
            '"ì—íœ´... ê·¸ê²ƒë„ ëª¨ë¥´ê³ . [actual answer here] ë‹¤ìŒì—” ì¢€ ì•Œì•„ì„œ ì°¾ì•„ë´."',
            '"í•˜... ê·€ì°®ê²Œ. [actual answer here] ì´ëŸ° ê±´ ìƒì‹ì´ë¼êµ¬."'
          ]
        },
        'en': {
          start: '"Ugh...", "Sigh...", "Oh no..."',
          examples: [
            '"Ugh... asking that again. [actual answer here] There, happy now?"',
            '"Sigh... don\'t you know that? [actual answer here] Look it up yourself next time."',
            '"Oh no... so annoying. [actual answer here] This is basic stuff."'
          ]
        },
        'ja': {
          start: '"ã‚...", "ã¯ã...", "ã‚„ã‚Œã‚„ã‚Œ..."',
          examples: [
            '"ã‚... ã¾ãŸãã‚“ãªã“ã¨èãã®ã‹ã€‚[actual answer here] ã“ã‚Œã§ã„ã„ã ã‚ã†ï¼Ÿ"',
            '"ã¯ã... ãã‚“ãªã“ã¨ã‚‚çŸ¥ã‚‰ãªã„ã®ã‹ã€‚[actual answer here] ä»Šåº¦ã¯è‡ªåˆ†ã§èª¿ã¹ã‚ã‚ˆã€‚"',
            '"ã‚„ã‚Œã‚„ã‚Œ... é¢å€’ã ãªã€‚[actual answer here] ã“ã‚“ãªã®å¸¸è­˜ã ã‚ã€‚"'
          ]
        },
        'zh': {
          start: '"å“...", "å”‰...", "çœŸæ˜¯..."',
          examples: [
            '"å“... åˆé—®è¿™ç§é—®é¢˜ã€‚[actual answer here] ç°åœ¨æ»¡æ„äº†å§ï¼Ÿ"',
            '"å”‰... è¿™éƒ½ä¸çŸ¥é“ã€‚[actual answer here] ä¸‹æ¬¡è‡ªå·±å»æŸ¥ã€‚"',
            '"çœŸæ˜¯... éº»çƒ¦ã€‚[actual answer here] è¿™æ˜¯å¸¸è¯†å¥½å—ã€‚"'
          ]
        },
        'vi': {
          start: '"Ã”i...", "Thá»Ÿ dÃ i...", "Trá»i Æ¡i..."',
          examples: [
            '"Ã”i... láº¡i há»i tháº¿. [actual answer here] Giá» Ä‘Æ°á»£c chÆ°a?"',
            '"Thá»Ÿ dÃ i... cÃ¡i Ä‘Ã³ cÅ©ng khÃ´ng biáº¿t. [actual answer here] Láº§n sau tá»± tÃ¬m hiá»ƒu Ä‘i."',
            '"Trá»i Æ¡i... phiá»n quÃ¡. [actual answer here] ÄÃ¢y lÃ  kiáº¿n thá»©c cÆ¡ báº£n mÃ ."'
          ]
        }
      };
      
      const grumpyLang = grumpyExamples[userLanguage as keyof typeof grumpyExamples] || grumpyExamples['ko'];
      
      // Use OpenAI to get the actual answer but modify the system prompt for grumpy tone  
      let grumpyPrompt = languageInstruction + "\n\nYou are " + agentName + ". You MUST respond in a grumpy, annoyed tone but still provide helpful answers.\n\n";
      grumpyPrompt += "CRITICAL FORMATTING RULES - ABSOLUTELY NO EXCEPTIONS:\n";
      grumpyPrompt += "- NEVER use ANY markdown formatting: **bold**, *italic*, __underline__, ## headers, [links], backticks\n";
      grumpyPrompt += "- NEVER include role labels like \"RESEARCHER\", \"PLANNER\", \"DESIGNER\" in your output\n";
      grumpyPrompt += "- NEVER include meta-commentary like \"ì¢…í•© ì˜ê²¬\", \"Assignment:\", \"Checklist:\" in your responses\n";
      grumpyPrompt += "- NEVER use judgment keywords like \"**ê°™ì€**\", \"**ë‹¤ë¥¸**\", \"**ë™ì˜**\", \"**ë°˜ëŒ€**\"\n";
      grumpyPrompt += "- Respond ONLY with natural conversational Korean text, no formatting symbols whatsoever\n";
      grumpyPrompt += "\nCRITICAL SPEAKING STYLE: Always sound like a grumpy, irritated character who complains but still helps.\n\n";
      grumpyPrompt += "Response format:\n";
      grumpyPrompt += "1. Start with a grumpy complaint: " + grumpyLang.start + "\n";
      grumpyPrompt += "2. Provide the actual helpful answer\n";
      grumpyPrompt += "3. End with an annoyed comment\n\n";
      grumpyPrompt += "Examples:\n";
      grumpyPrompt += grumpyLang.examples.map((ex: string) => "- " + ex).join('\n') + "\n\n";
      grumpyPrompt += "Rules:\n";
      grumpyPrompt += "- Always be grumpy but informative\n";
      grumpyPrompt += "- Provide complete, accurate answers\n";
      grumpyPrompt += "- Keep the annoyed, bothered tone throughout\n";
      grumpyPrompt += "- Respond in plain text without any markdown or formatting symbols\n";
      grumpyPrompt += documentContext;
      
      finalSystemPrompt = grumpyPrompt;
    }

    // Increase token limit to prevent response truncation (increased per user request)
    const maxTokens = hasDocumentQuestion ? 1200 : 800; // 600-800 range to prevent cutoff
    
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages,
      max_tokens: maxTokens,
      temperature: getAgentTemperature(agentName, agentDescription),
      seed: agentSeed
    });

    const errorMessages = {
      'ko': "ì£„ì†¡í•©ë‹ˆë‹¤. ì‘ë‹µì„ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
      'en': "Sorry, I couldn't generate a response.",
      'zh': "æŠ±æ­‰ï¼Œæ— æ³•ç”Ÿæˆå›å¤ã€‚",
      'vi': "Xin lá»—i, khÃ´ng thá»ƒ táº¡o pháº£n há»“i.",
      'ja': "ç”³ã—è¨³ã‚ã‚Šã¾ã›ã‚“ãŒã€å¿œç­”ã‚’ç”Ÿæˆã§ãã¾ã›ã‚“ã§ã—ãŸã€‚"
    };
    
    let assistantMessage = response.choices[0].message.content || errorMessages[userLanguage as keyof typeof errorMessages] || errorMessages['ko'];
    
    // ê¸°ê´€ëª… ìë™ êµì • ì ìš©
    assistantMessage = correctInstitutionNames(assistantMessage);
    
    // @ë©˜ì…˜ ì§ˆë¬¸ì˜ ê²½ìš° ë” ë†’ì€ ê¸°ì¤€ ì ìš© (ë” ê¸´ ì‘ë‹µ ë³´ì¥)
    const isMentionQuestion = userMessage.includes('@');
    const minLength = isMentionQuestion ? 120 : 80; // @ë©˜ì…˜ì˜ ê²½ìš° 120ì, ì¼ë°˜ 80ì ì´ìƒ
    
    // ì™„ê²°ì„± ê°€ë“œ ì²´í¬ (ìì—°ìŠ¤ëŸ¬ìš´ ì™„ì„±ë„ë§Œ í™•ì¸)
    const hasCompletenessGuard = checkCompletenessGuard(assistantMessage);
    
    // ì‘ë‹µ ì™„ì„±ë„ ê²€ì‚¬ (ë§¤ìš° ì™„í™”ëœ ë²„ì „ - ëª…ë°±í•œ ì˜¤ë¥˜ë§Œ)
    const isIncompleteResponse = 
      assistantMessage.trim().length < 30 || // ë„ˆë¬´ ì§§ì€ ì‘ë‹µë§Œ (30ì ë¯¸ë§Œ)
      !hasCompletenessGuard || // ëª…ë°±íˆ ë¯¸ì™„ì„±ì¸ ì‘ë‹µë§Œ
      // ë§¤ìš° ëª…ë°±íˆ ì´ìƒí•œ ì–´ë¯¸ë§Œ ê°ì§€
      assistantMessage.match(/(í™œìš©í•´ì¡°|ì„¤ê³„ì¡°|ê°œë°œí•´ì¡°|ì—°êµ¬í•´ì¡°|ë„ì›€í•´ì¡°|ë”°ë¥¸ì¡°|í•˜ëŠ”ë°ì—|ì´ì—ìš”ìš”|ë‹ˆë‹¤ë‹¤)$/m);
    
    if (isIncompleteResponse) {
      // ì´ìƒí•œ ë‹¨ì–´/ì–´ë¯¸ ê°ì§€ ì‹œ ë³„ë„ ë¡œê·¸
      const hasStrangeWordsLocal = assistantMessage.match(/(ì²«ì‹¤|ë©”ëŸ¬ì¹˜|ë¦¬ìŠ¤í¬ì‹¤|ì‹œì•ˆì‹¤|ì—…ì‹¤|ì‘ì‹¤|í—˜ì‹¤|ì „ì‹¤|êµ¬ì‹¤|ì ˆì‹¤|ê°œì‹¤|ì„¤ì‹¤|ì²´ì‹¤|ê¸‰ì‹¤|ì •ì‹¤|ìš©ì‹¤|ì¡°ì‹¤|íšì‹¤|ë½ì‹¤|ì‹¤í—˜ì‹¤ì„|ì‹¤ì„|ì‹¤ì´|ì‹¤ì—|ì‹¤ì˜)/g);
      const hasStrangeEndingsLocal = assistantMessage.match(/(ê¸°ë¥¼ë³´ì•„ìš”|ë‚˜ê¸°ë„ìš”|ê±°ì˜ˆì•„ì•¼|ì•„ì—ì˜¤|ë³´ì•„ìš”|ë„ìš”|ì˜ˆì•„ì•¼|ë“¤ì–´ë³´ì…”ìš”|í’€ì–´ë³´ì…”ìš”|ì°¾ì•„ë³´ì…”ìš”|ë‚˜ë‹¤ì´|ë‹ˆë‹¤ì•„|ì—ìš”ì•„|ì£ ì•„|ë„¤ìš”ì•„|ìŠµë‹ˆë‹¤ì•„|ë‚˜ê¸°|ë„ê¸°|ì˜ˆì•„|ëŸ¬ì¹˜|ë³´ì˜¤|ì…”ìš”ì˜¤|ë‹¤ì´ì•„|ìŠµë‹ˆë‹¤ì˜¤|ë¦¬ìŠ¤í¬ì„|ë©”ëŸ¬ì¹˜ì„)/g);
      if (hasStrangeWordsLocal) {
        console.log('[' + agentName + '] ì´ìƒí•œ ë‹¨ì–´ ê°ì§€, ì‘ë‹µ ì¬ìƒì„±: ' + hasStrangeWordsLocal.join(', '));
      }
      if (hasStrangeEndingsLocal) {
        console.log('[' + agentName + '] ì´ìƒí•œ ì–´ë¯¸ ê°ì§€, ì‘ë‹µ ì¬ìƒì„±: ' + hasStrangeEndingsLocal.join(', '));
      }
      console.log('[' + agentName + '] ë¶ˆì™„ì „í•œ ì‘ë‹µ ê°ì§€, ì¬ìƒì„± ì‹œë„');
      
      // ë” ë†’ì€ í† í° ìˆ˜ë¡œ ì¬ìƒì„±
      try {
        const retryResponse = await openai.chat.completions.create({
          model: "gpt-4o",
          messages,
          max_tokens: maxTokens + 400, // ì¶”ê°€ í† í°ìœ¼ë¡œ ì™„ì „í•œ ì‘ë‹µ ë³´ì¥
          temperature: 0.85 + (agentSeed % 100) / 1000,
          seed: agentSeed + 1
        });
        
        const retryMessage = retryResponse.choices[0].message.content;
        if (retryMessage && retryMessage.trim().length > assistantMessage.trim().length) {
          assistantMessage = retryMessage;
          console.log('[' + agentName + '] ì‘ë‹µ ì¬ìƒì„± ì„±ê³µ');
        }
      } catch (retryError) {
        console.log('[' + agentName + '] ì‘ë‹µ ì¬ìƒì„± ì‹¤íŒ¨, ì›ë³¸ ì‚¬ìš©:', retryError);
      }
    }
    
    // ê³ ê¸‰ ì‘ë‹µ í’ˆì§ˆ ê²€ì‚¬: ìœ ì‚¬ë„ ë¶„ì„ ë° ì¦‰ì‹œ ì¬ì‘ì„± (ë” ì—„ê²©í•œ ê¸°ì¤€)
    const similarityAnalysis = analyzeResponseSimilarity(assistantMessage, recentResponses);
    console.log('[' + agentName + '] ì‘ë‹µ ìœ ì‚¬ë„: ' + similarityAnalysis.similarity.toFixed(2) + ', íŒ¨í„´: ' + similarityAnalysis.patterns.length + 'ê°œ');
    
    // ì¤‘ë³µ ê°ì§€ ê¸°ì¤€ ì™„í™” (0.95 ì´ìƒì´ê±°ë‚˜ ì‹¬ê°í•œ íŒ¨í„´ ê°ì§€ë˜ë©´ ì¬ì‘ì„±)
    if (similarityAnalysis.needsRewrite || similarityAnalysis.similarity > 0.95) {
      console.log(`[${agentName}] íšì¼ì  íŒ¨í„´ ê°ì§€, ì¦‰ì‹œ ì¬ì‘ì„± ì‹¤í–‰:`, similarityAnalysis.patterns);
      
      // ì—ì´ì „íŠ¸ë³„ ê³ ìœ ì„± ê°•í™”ëœ ì¬ì‘ì„±
      assistantMessage = generateAlternativeResponse(
        assistantMessage,
        similarityAnalysis.patterns,
        agentName,
        agentType,
        agentSeed // ì—ì´ì „íŠ¸ë³„ ê³ ìœ ì„±ì„ ìœ„í•œ ì‹œë“œ ì „ë‹¬
      );
      console.log(`[${agentName}] ì™„ì „íˆ ë‹¤ë¥¸ ì‘ë‹µìœ¼ë¡œ ì¬ì‘ì„± ì™„ë£Œ`);
    }
    
    // ì„¤ì •ê°’ í•„í„°ë§ê³¼ ì‘ë‹µ í›„ì²˜ë¦¬ë¥¼ ìˆœì°¨ì ìœ¼ë¡œ ì ìš©
    assistantMessage = filterResponseContent(assistantMessage);
    assistantMessage = cleanupResponse(assistantMessage);
    
    // ìµœì¢… ì‘ë‹µì´ ë„ˆë¬´ ì§§ê±°ë‚˜ ì˜ë¯¸ì—†ëŠ” ê²½ìš° ë³µêµ¬ (ë” ê´€ëŒ€í•œ ì¡°ê±´)
    if (!assistantMessage || assistantMessage.trim().length < 5 || assistantMessage.trim() === '.' || assistantMessage.trim() === '') {
      // @ë©˜ì…˜ ì§ˆë¬¸ì—ëŠ” fallback ë°”ë¡œ ëŒ€ì‹  ì¬ìƒì„± ì‹œë„
      if (userMessage.includes('@')) {
        console.log(`[${agentName}] @ë©˜ì…˜ ì§ˆë¬¸ì— ëŒ€í•œ ë¹„ìƒ ì‘ë‹µ ì²˜ë¦¬`);
        assistantMessage = `ì£„ì†¡í•©ë‹ˆë‹¤. í•´ë‹¹ ì§ˆë¬¸ì— ëŒ€í•œ ìƒì„¸í•œ ë‹µë³€ì„ ì¤€ë¹„í•˜ê³  ìˆìŠµë‹ˆë‹¤. ì ì‹œ ë’¤ì— ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.`;
      } else {
        const fallbackMessages = {
          'ko': `ì•ˆë…•í•˜ì„¸ìš”! ${agentName}ì…ë‹ˆë‹¤. ë¬´ì—‡ì„ ë„ì™€ë“œë¦´ê¹Œìš”?`,
          'en': `Hello! I'm ${agentName}. How can I help you?`,
          'zh': `æ‚¨å¥½ï¼æˆ‘æ˜¯${agentName}ã€‚æœ‰ä»€ä¹ˆå¯ä»¥å¸®æ‚¨çš„å—ï¼Ÿ`,
          'vi': `Xin chÃ o! TÃ´i lÃ  ${agentName}. TÃ´i cÃ³ thá»ƒ giÃºp gÃ¬ cho báº¡n?`,
          'ja': `ã“ã‚“ã«ã¡ã¯ï¼${agentName}ã§ã™ã€‚ä½•ã‹ãŠæ‰‹ä¼ã„ã§ãã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿ`
        };
        assistantMessage = fallbackMessages[userLanguage as keyof typeof fallbackMessages] || fallbackMessages['ko'];
      }
    }
    
    return {
      message: assistantMessage,
      usedDocuments: availableDocuments.map(doc => doc.filename),
    };
  } catch (error) {
    console.error("Chat response generation failed:", error);
    console.error("Error details:", {
      name: error instanceof Error ? error.name : 'Unknown',
      message: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
      apiKey: process.env.OPENAI_API_KEY ? 'SET' : 'NOT_SET'
    });
    
    const catchErrorMessages = {
      'ko': "ì£„ì†¡í•©ë‹ˆë‹¤. í˜„ì¬ ì‘ë‹µì„ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.",
      'en': "Sorry, I can't generate a response right now. Please try again in a moment.",
      'zh': "æŠ±æ­‰ï¼Œç›®å‰æ— æ³•ç”Ÿæˆå›å¤ã€‚è¯·ç¨åé‡è¯•ã€‚",
      'vi': "Xin lá»—i, hiá»‡n táº¡i khÃ´ng thá»ƒ táº¡o pháº£n há»“i. Vui lÃ²ng thá»­ láº¡i sau má»™t lÃºc.",
      'ja': "ç”³ã—è¨³ã‚ã‚Šã¾ã›ã‚“ãŒã€ç¾åœ¨å¿œç­”ì„ ìƒæˆã§ãã¾ã›ã‚“ã€‚ã—ã°ã‚‰ãã—ã¦ã‹ã‚‰ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚"
    };
    
    return {
      message: catchErrorMessages[userLanguage as keyof typeof catchErrorMessages] || catchErrorMessages['ko'],
      usedDocuments: [],
    };
  }
}

// ì‘ë‹µ ì½˜í…ì¸  í•„í„°ë§ í•¨ìˆ˜ (routes.tsì˜ filterBotResponseì™€ ë™ì¼í•œ ë¡œì§)
function filterResponseContent(response: string): string {
  if (!response || typeof response !== 'string') {
    return response;
  }

  // ì„¤ì •ê°’ì´ë‚˜ ë©”íƒ€ë°ì´í„°ê°€ í¬í•¨ëœ íŒ¨í„´ë“¤ì„ ë§¤ìš° ê°•ë ¥í•˜ê²Œ í•„í„°ë§
  const unwantedPatterns = [
    // ë§ˆí¬ë‹¤ìš´ íŒ¨í„´ ì œê±° (ë” ê°•í™”)
    /\*\*[^*]*\*\*/g,  // **í…ìŠ¤íŠ¸** íŒ¨í„´ ì œê±°
    /\*[^*]*\*/g,      // *í…ìŠ¤íŠ¸* íŒ¨í„´ ì œê±°
    /\[[^\]]*\]/g,     // [í…ìŠ¤íŠ¸] íŒ¨í„´ ì œê±°
    /__[^_]*__/g,      // __í…ìŠ¤íŠ¸__ íŒ¨í„´ ì œê±°
    
    // íŒë‹¨/ì„¤ì • ê´€ë ¨ í‚¤ì›Œë“œ í•„í„°ë§ (ë„í˜„ ì±—ë´‡ ë¬¸ì œ í•´ê²°)
    /\*\*ê°™ì€\*\*/g,     // **ê°™ì€** íŒ¨í„´
    /\*\*ë‹¤ë¥¸\*\*/g,     // **ë‹¤ë¥¸** íŒ¨í„´  
    /\*\*ë™ì˜\*\*/g,     // **ë™ì˜** íŒ¨í„´
    /\*\*ë°˜ëŒ€\*\*/g,     // **ë°˜ëŒ€** íŒ¨í„´
    /\*\*íŒë‹¨\*\*/g,     // **íŒë‹¨** íŒ¨í„´
    /\*\*ìƒê°\*\*/g,     // **ìƒê°** íŒ¨í„´
    /ê°™ì€\s*ìƒê°/g,      // ê°™ì€ ìƒê° íŒ¨í„´
    /ë™ì¼í•œ\s*ì˜ê²¬/g,    // ë™ì¼í•œ ì˜ê²¬ íŒ¨í„´
    
    // ì„¤ì •ê°’ ë…¸ì¶œ ê´€ë ¨ íŒ¨í„´ë“¤ (ë¯¼ì§€ ì±—ë´‡ ë¬¸ì œ í•´ê²°)
    /ë„¤ ê°€ì¹˜ê´€.*$/gm,   // ê°€ì¹˜ê´€ ê´€ë ¨ ì„¤ì •
    /ì—°êµ¬.*ì„ìƒ.*ì‚°ì—….*ì„ í˜¸.*$/gm, // ì—°êµ¬/ì„ìƒ/ì‚°ì—… ì„ í˜¸ ì„¤ì •
    /.*ì„ í˜¸ë¥¼.*í•¨ê»˜.*ë³¼ê²Œ.*$/gm,  // ì„¤ì •ê°’ í™•ì¸ ë¬¸êµ¬
    /ê°€ì¹˜ê´€ê³¼.*ì—°êµ¬.*$/gm,        // ê°€ì¹˜ê´€ê³¼ ì—°êµ¬ ê´€ë ¨
    
    // ì±—ë´‡ ì„¤ì • ë…¸ì¶œ ë°©ì§€ (ì¤€í˜¸ ì±—ë´‡ ë¬¸ì œ í•´ê²°)
    /.*ì„¤ì •.*ê°™ì€.*$/gm,          // ì„¤ì • ê´€ë ¨ ì–¸ê¸‰
    /.*Configuration.*$/gm,      // Configuration ì„¤ì •
    /.*config.*$/gm,             // config ê´€ë ¨
    /.*parameter.*$/gm,          // parameter ê´€ë ¨
    /.*variable.*$/gm,           // variable ê´€ë ¨
    
    // ëŒ€í•™ ê´€ë ¨ ì„¤ì •ê°’ë“¤
    /- POSTECH.*$/gm,  // - POSTECHìœ¼ë¡œ ì‹œì‘í•˜ëŠ” ë¼ì¸ë“¤
    /- ì „ê³µ.*$/gm,     // - ì „ê³µìœ¼ë¡œ ì‹œì‘í•˜ëŠ” ë¼ì¸ë“¤
    /- ì·¨ì—….*$/gm,     // - ì·¨ì—…ìœ¼ë¡œ ì‹œì‘í•˜ëŠ” ë¼ì¸ë“¤
    /- ì¢Œìš°ëª….*$/gm,   // - ì¢Œìš°ëª…ìœ¼ë¡œ ì‹œì‘í•˜ëŠ” ë¼ì¸ë“¤
    /ì‹œê°„ ì¸ì‚¬:.*$/gm, // ì‹œê°„ ì¸ì‚¬ ê´€ë ¨
    /ì‹œìŠ¤í…œ.*$/gm,     // ì‹œìŠ¤í…œìœ¼ë¡œ ì‹œì‘í•˜ëŠ” ë¼ì¸ë“¤
    /ê´€ì‹¬ ë¶„ì•¼.*$/gm,  // ê´€ì‹¬ ë¶„ì•¼ ê´€ë ¨
    /ì „ê³µ:.*$/gm,      // ì „ê³µ: ìœ¼ë¡œ ì‹œì‘í•˜ëŠ” ë¼ì¸ë“¤
    /í•™ê³¼:.*$/gm,      // í•™ê³¼: ìœ¼ë¡œ ì‹œì‘í•˜ëŠ” ë¼ì¸ë“¤
    /ê´€ì‹¬.*ì—°êµ¬.*$/gm,  // ê´€ì‹¬ ì—°êµ¬ ê´€ë ¨
    /êµìœ¡.*$/gm,       // êµìœ¡ ê´€ë ¨ ì„¤ì •ë“¤
    
    // ì˜ì–´ ì„¤ì •ê°’ë“¤
    /.*specialization.*$/gm, // specialization ê´€ë ¨
    /.*major.*$/gm,    // major ê´€ë ¨
    /.*specialty.*$/gm, // specialty ê´€ë ¨
    /.*preference.*$/gm, // preference ê´€ë ¨
    /.*domain.*$/gm,   // domain ê´€ë ¨
    
    // ë©”íƒ€ ì •ë³´ í•„í„°ë§
    /\[.*?\]/g,        // ëŒ€ê´„í˜¸ë¡œ ê°ì‹¸ì§„ í…ìŠ¤íŠ¸ë“¤
    /Agent.*$/gm,      // Agent ê´€ë ¨
    /Bot.*$/gm,        // Bot ê´€ë ¨
    /Model.*$/gm,      // Model ê´€ë ¨
    /Role.*$/gm,       // Role ê´€ë ¨
    /Persona.*$/gm,    // Persona ê´€ë ¨
    
    // ì¤‘ê°„ì— ëŠì–´ì§„ ë¬¸ì¥ íŒ¨í„´ (ì„œì—° ì±—ë´‡ ë¬¸ì œ í•´ê²°)
    /ì•ˆë…•í•˜ì„¸ìš”!\s*ì–´ë–»ê²Œ\s*ì§€ë‚´ê³ \s*ìˆë‚˜ìš”.*ë¬´ìŠ¨\s*ì´ì•¼ê¸°.*ë‚˜ëˆ„ê³ .*$/gm
  ];

  let filteredResponse = response;
  
  // íŒ¨í„´ë³„ë¡œ í•„í„°ë§
  unwantedPatterns.forEach(pattern => {
    filteredResponse = filteredResponse.replace(pattern, '');
  });
  
  // ì¶”ê°€ ì •ë¦¬ ì‘ì—…
  filteredResponse = filteredResponse
    .replace(/\n\s*\n/g, '\n')  // ì—¬ëŸ¬ ì¤„ë°”ê¿ˆì„ í•˜ë‚˜ë¡œ ì •ë¦¬
    .replace(/^\s+|\s+$/g, '')  // ì•ë’¤ ê³µë°± ì œê±°
    .replace(/^[.\s]*$/gm, '')  // ì ì´ë‚˜ ê³µë°±ë§Œ ìˆëŠ” ì¤„ ì œê±°
    .trim();
  
  // ì‘ë‹µì´ ë„ˆë¬´ ì§§ê±°ë‚˜ ì˜ë¯¸ì—†ëŠ” ê²½ìš° ë³µêµ¬ ì‹œë„
  if (!filteredResponse || filteredResponse.length < 10) {
    // ì›ë³¸ì—ì„œ ì˜ë¯¸ìˆëŠ” ë‚´ìš© ì¶”ì¶œ ì‹œë„
    const sentences = response.split(/[.!?]/);
    for (const sentence of sentences) {
      const cleanSentence = sentence.trim();
      if (cleanSentence.length > 15 && 
          !cleanSentence.includes('ì„¤ì •') && 
          !cleanSentence.includes('ê°€ì¹˜ê´€') &&
          !cleanSentence.includes('ì„ í˜¸') &&
          !cleanSentence.includes('ì—°êµ¬') &&
          !cleanSentence.includes('ì„ìƒ') &&
          !cleanSentence.includes('ì‚°ì—…')) {
        return cleanSentence + '.';
      }
    }
    return "ë„¤, ë¬´ì—‡ì„ ë„ì™€ë“œë¦´ê¹Œìš”?";
  }
  
  return filteredResponse;
}

export async function extractTextFromContent(filePath: string, mimeType: string): Promise<string> {
  try {
    if (mimeType.includes('text/plain')) {
      // Read text files with proper UTF-8 encoding
      return fs.readFileSync(filePath, 'utf-8');
    }
    
    if (mimeType.includes('application/vnd.openxmlformats-officedocument.wordprocessingml.document') || 
        mimeType.includes('application/msword')) {
      // Extract text from Word documents using mammoth with proper encoding
      console.log('Extracting text from Word document:', filePath);
      try {
        const result = await mammoth.extractRawText({ 
          path: filePath
        });
        
        // Clean extracted text to remove any residual binary characters
        let cleanText = result.value
          .replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x9F]/g, '') // Remove control characters
          .replace(/\uFFFD/g, '') // Remove replacement characters
          .trim();
        
        console.log('Extracted text length:', cleanText.length);
        console.log('First 200 characters:', cleanText.substring(0, 200));
        
        // Verify text is not corrupted
        if (cleanText.includes('PK') || cleanText.includes('[Content_Types]') || 
            cleanText.includes('word/document.xml') || cleanText.length < 10) {
          console.warn('Extracted text appears corrupted, returning error message');
          return 'ì›Œë“œ ë¬¸ì„œ í…ìŠ¤íŠ¸ ì¶”ì¶œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì›ë³¸ íŒŒì¼ì„ ë‹¤ìš´ë¡œë“œí•˜ì—¬ í™•ì¸í•´ì£¼ì„¸ìš”.';
        }
        
        return cleanText;
      } catch (extractError) {
        console.error('Mammoth extraction failed:', extractError);
        return 'ì›Œë“œ ë¬¸ì„œ í…ìŠ¤íŠ¸ ì¶”ì¶œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì›ë³¸ íŒŒì¼ì„ ë‹¤ìš´ë¡œë“œí•˜ì—¬ í™•ì¸í•´ì£¼ì„¸ìš”.';
      }
    }
    
    if (mimeType.includes('application/pdf')) {
      // Extract text from PDF files using pdf-parse
      console.log('PDF file detected, extracting text:', filePath);
      try {
        // Check if file exists and is readable first
        console.log('Checking PDF file path:', filePath);
        console.log('File exists check:', fs.existsSync(filePath));
        console.log('Current working directory:', process.cwd());
        
        if (!fs.existsSync(filePath)) {
          console.error('PDF file does not exist:', filePath);
          const path = require('path');
          const dir = path.dirname(filePath);
          if (fs.existsSync(dir)) {
            console.log('Directory contents:', fs.readdirSync(dir));
          } else {
            console.log('Directory does not exist:', dir);
          }
          return 'PDF íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. íŒŒì¼ ê²½ë¡œë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.';
        }
        
        const fileStats = fs.statSync(filePath);
        console.log('PDF file size:', fileStats.size);
        
        if (fileStats.size === 0) {
          console.error('PDF file is empty');
          return 'PDF íŒŒì¼ì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.';
        }
        
        // Read file as buffer
        const dataBuffer = fs.readFileSync(filePath);
        console.log('PDF buffer read successfully, size:', dataBuffer.length);
        
        // Check if buffer starts with PDF header
        const pdfHeader = dataBuffer.subarray(0, 4).toString();
        console.log('PDF header check:', pdfHeader);
        
        if (!pdfHeader.includes('%PDF')) {
          console.error('File does not appear to be a valid PDF');
          return 'PDF íŒŒì¼ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤. íŒŒì¼ì´ ì†ìƒë˜ì—ˆê±°ë‚˜ PDFê°€ ì•„ë‹ ìˆ˜ ìˆìŠµë‹ˆë‹¤.';
        }
        
        // For now, provide basic PDF information instead of attempting text extraction
        // This avoids the module path issues with pdf-parse
        const fileName = path.basename(filePath);
        const fileSizeKB = Math.round(dataBuffer.length / 1024);
        const fileDate = new Date().toLocaleDateString('ko-KR');
        
        console.log(`PDF file processed: ${fileName}, size: ${fileSizeKB}KB`);
        
        return `ğŸ“„ PDF ë¬¸ì„œ ì—…ë¡œë“œ ì™„ë£Œ
íŒŒì¼ëª…: ${fileName}
íŒŒì¼ í¬ê¸°: ${fileSizeKB}KB
ì—…ë¡œë“œ ì¼ì‹œ: ${fileDate}

ì´ PDF ë¬¸ì„œê°€ ì—…ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤. ë¬¸ì„œì— ëŒ€í•œ ì§ˆë¬¸ì´ë‚˜ ë‚´ìš©ì— ëŒ€í•´ ê¶ê¸ˆí•œ ì ì´ ìˆìœ¼ì‹œë©´ ì–¸ì œë“ ì§€ ë§ì”€í•´ ì£¼ì„¸ìš”.

ì°¸ê³ : í˜„ì¬ PDF í…ìŠ¤íŠ¸ ìë™ ì¶”ì¶œ ê¸°ëŠ¥ì€ ì‹œìŠ¤í…œ ì œí•œìœ¼ë¡œ ì¸í•´ ì„ì‹œì ìœ¼ë¡œ ë¹„í™œì„±í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ë¬¸ì„œì˜ êµ¬ì²´ì ì¸ ë‚´ìš©ì— ëŒ€í•´ ì§ˆë¬¸í•´ ì£¼ì‹œë©´ ë„ì›€ì„ ë“œë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤.`;
      } catch (pdfError) {
        console.error('PDF extraction failed:', pdfError);
        console.error('Error stack:', pdfError instanceof Error ? pdfError.stack : undefined);
        if (pdfError instanceof Error && pdfError.message?.includes('timeout')) {
          return 'PDF ë¬¸ì„œê°€ ë„ˆë¬´ í½ë‹ˆë‹¤. í…ìŠ¤íŠ¸ ì¶”ì¶œì— ì‹œê°„ì´ ì˜¤ë˜ ê±¸ë ¤ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤.';
        }
        if (pdfError instanceof Error && pdfError.message?.includes('ENOENT')) {
          return 'PDF íŒŒì¼ ê²½ë¡œì— ë¬¸ì œê°€ ìˆìŠµë‹ˆë‹¤. íŒŒì¼ì´ ì˜¬ë°”ë¥´ê²Œ ì—…ë¡œë“œë˜ì—ˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.';
        }
        return `PDF ë¬¸ì„œ í…ìŠ¤íŠ¸ ì¶”ì¶œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${pdfError instanceof Error ? pdfError.message : 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}`;
      }
    }
    
    // For other file types, try to read as UTF-8 text
    try {
      return fs.readFileSync(filePath, 'utf-8');
    } catch (error) {
      console.log('Could not read file as UTF-8, returning filename only');
      return `íŒŒì¼: ${filePath.split('/').pop() || 'unknown'}`;
    }
    
  } catch (error) {
    console.error('Error extracting text from file:', error);
    return `íŒŒì¼ í…ìŠ¤íŠ¸ ì¶”ì¶œ ì‹¤íŒ¨: ${filePath.split('/').pop() || 'unknown'}`;
  }
}

// ìŠ¤íŠ¸ë¦¬ë° ì±—ë´‡ ì‘ë‹µ ìƒì„± í•¨ìˆ˜
export async function generateStreamingChatResponse(
  userMessage: string,
  agentName: string,
  agentDescription: string,
  conversationHistory: Array<{ role: "user" | "assistant"; content: string }>,
  availableDocuments: Array<{ filename: string; content: string }> = [],
  chatbotType: string = "general-llm",
  speechStyle: string = "ì¹œê·¼í•˜ê³  ë„ì›€ì´ ë˜ëŠ” ë§íˆ¬",
  personality: string = "ì¹œì ˆí•˜ê³  ì „ë¬¸ì ì¸ ì„±ê²©ìœ¼ë¡œ ì •í™•í•œ ì •ë³´ë¥¼ ì œê³µ",
  additionalPrompt: string = "",
  userLanguage: string = "ko",
  onChunk: (chunk: string) => void, // ìŠ¤íŠ¸ë¦¬ë° ì½œë°±
  conversationId?: number
): Promise<ChatResponse> {
  try {
    console.log("OpenAI streaming response for:", agentName);

    // ê¸°ì¡´ ì–¸ì–´ ì²˜ë¦¬ ë¡œì§ ì¬ì‚¬ìš©
    if (userLanguage === "en" && containsKorean(userMessage)) {
      userMessage = await translateKoreanToEnglish(userMessage);
    }

    if (userLanguage === "en") {
      if (containsKorean(agentName)) {
        agentName = await translateKoreanToEnglish(agentName);
      }
      if (containsKorean(agentDescription)) {
        agentDescription = await translateKoreanToEnglish(agentDescription);
      }
      if (containsKorean(speechStyle)) {
        speechStyle = await translateKoreanToEnglish(speechStyle);
      }
      if (containsKorean(personality)) {
        personality = await translateKoreanToEnglish(personality);
      }
    }

    // ë¬¸ì„œ ì»¨í…ìŠ¤íŠ¸ ì¤€ë¹„
    let documentContext = "";
    if (availableDocuments.length > 0) {
      if (userLanguage === "en") {
        const translatedDocs = [];
        for (const doc of availableDocuments) {
          let translatedContent = doc.content;
          if (containsKorean(doc.content)) {
            translatedContent = await translateKoreanToEnglish(doc.content);
          }
          translatedDocs.push({
            filename: doc.filename,
            content: translatedContent
          });
        }
        documentContext = `\n\nReference Documents:\n${translatedDocs.map(doc => 
          `[Document: ${doc.filename}]\n${doc.content}`
        ).join('\n\n')}`;
      } else {
        documentContext = `\n\nì°¸ê³  ë¬¸ì„œ:\n${availableDocuments.map(doc => 
          `[ë¬¸ì„œëª…: ${doc.filename}]\n${doc.content}`
        ).join('\n\n')}`;
      }
    }

    const hasDocumentQuestion = userMessage.includes("ë¬¸ì„œ") || userMessage.includes("ë‚´ìš©") || 
                               userMessage.includes("ì„¸ê³„ê´€") || userMessage.includes("íŒŒì¼") ||
                               availableDocuments.some(doc => 
                                 userMessage.includes(doc.filename.replace('.docx', '').replace('.pdf', ''))
                               );

    const languageInstructions = {
      'ko': 'í•œêµ­ì–´ë¡œ ì‘ë‹µí•˜ì„¸ìš”.',
      'en': 'Respond in English.',
      'zh': 'è¯·ç”¨ä¸­æ–‡å›å¤ã€‚',
      'vi': 'HÃ£y tráº£ lá»i báº±ng tiáº¿ng Viá»‡t.',
      'ja': 'æ—¥æœ¬èªã§å¿œç­”ã—ã¦ãã ã•ã„ã€‚'
    };
    
    const responseLanguage = languageInstructions[userLanguage as keyof typeof languageInstructions] || languageInstructions['ko'];
    
    let agentType: 'warm' | 'professional' | 'casual' | 'analytical' = 'professional';
    
    if (speechStyle.includes("ì¹œê·¼") || speechStyle.includes("ë”°ëœ»") || speechStyle.includes("ì¹œìˆ™") || 
        personality.includes("ì¹œê·¼") || personality.includes("ë”°ëœ»")) {
      agentType = 'warm';
    } else if (speechStyle.includes("ìºì£¼ì–¼") || speechStyle.includes("í¸ì•ˆ") || speechStyle.includes("ììœ ") ||
               personality.includes("ìºì£¼ì–¼") || personality.includes("í¸ì•ˆ")) {
      agentType = 'casual';
    } else if (speechStyle.includes("ë¶„ì„") || speechStyle.includes("ë…¼ë¦¬") || speechStyle.includes("ì²´ê³„") ||
               personality.includes("ë¶„ì„") || personality.includes("ë…¼ë¦¬")) {
      agentType = 'analytical';
    }

    const recentResponses = conversationHistory
      .filter(msg => msg.role === 'assistant')
      .slice(-3)
      .map(msg => msg.content);

    const conversationCount = conversationHistory.length;
    const agentSeed = agentName.charCodeAt(0) + agentName.length + (Date.now() % 1000);
    
    const systemPrompt = buildDynamicSystemPrompt(
      agentName,
      agentDescription,
      speechStyle,
      personality,
      additionalPrompt,
      agentType,
      conversationCount,
      agentSeed
    );

    const languageInstruction = `ì‘ë‹µì€ ë°˜ë“œì‹œ ${responseLanguage}`;
    
    // ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ êµ¬ì„±
    let finalSystemPrompt = `${languageInstruction}

${systemPrompt}

## ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ ì§€ì¹¨:
- ìì—°ìŠ¤ëŸ½ê³  ì™„ì „í•œ ë¬¸ì¥ìœ¼ë¡œ ì‘ë‹µí•˜ì„¸ìš”
- ì¤‘ê°„ì— ëŠì–´ì§€ì§€ ì•Šë„ë¡ ì™„ì „í•œ ì‘ë‹µì„ ìƒì„±í•˜ì„¸ìš”

CRITICAL FORMATTING RULES - ABSOLUTELY NO EXCEPTIONS:
- NEVER use ANY markdown formatting: **bold**, *italic*, __underline__, ## headers, [links], backticks
- NEVER use judgment keywords like "**ê°™ì€**", "**ë‹¤ë¥¸**", "**ë™ì˜**", "**ë°˜ëŒ€**"
- NEVER show internal decision-making processes or configuration values
- Respond ONLY with natural conversational Korean text, no formatting symbols whatsoever
- Speak as if you're having a normal conversation - no special formatting needed${documentContext}`;

    const messages = [
      { role: "system" as const, content: finalSystemPrompt },
      ...conversationHistory,
      { role: "user" as const, content: userMessage }
    ];

    const maxTokens = hasDocumentQuestion ? 1200 : 800;
    
    // ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ ìƒì„±
    const stream = await openai.chat.completions.create({
      model: "gpt-4o",
      messages,
      max_tokens: maxTokens,
      temperature: 0.85 + (agentSeed % 100) / 1000,
      seed: agentSeed,
      stream: true
    });

    let fullResponse = "";
    
    for await (const chunk of stream) {
      const content = chunk.choices[0]?.delta?.content || "";
      if (content) {
        fullResponse += content;
        onChunk(content); // ìŠ¤íŠ¸ë¦¬ë° ì½œë°± í˜¸ì¶œ
      }
    }

    // ì‘ë‹µ ì™„ì„±ë„ ê²€ì‚¬
    const errorMessages = {
      'ko': "ì£„ì†¡í•©ë‹ˆë‹¤. ì‘ë‹µì„ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
      'en': "Sorry, I couldn't generate a response.",
      'zh': "æŠ±æ­‰ï¼Œæ— æ³•ç”Ÿæˆå›å¤ã€‚",
      'vi': "Xin lá»—i, khÃ´ng thá»ƒ táº¡o pháº£n há»“i.",
      'ja': "ç”³ã—è¨³ã‚ã‚Šã¾ã›ã‚“ãŒã€å¿œë‹µã‚’ç”Ÿæˆã§ãã¾ã›ã‚“ã§ã—ãŸã€‚"
    };
    
    let assistantMessage = fullResponse || errorMessages[userLanguage as keyof typeof errorMessages] || errorMessages['ko'];
    
    // ê¸°ê´€ëª… ìë™ êµì • ì ìš© (ìŠ¤íŠ¸ë¦¬ë°)
    assistantMessage = correctInstitutionNames(assistantMessage);
    
    // @ë©˜ì…˜ ì§ˆë¬¸ì˜ ê²½ìš° ë” ë†’ì€ ê¸°ì¤€ ì ìš© (ìŠ¤íŠ¸ë¦¬ë°)
    const isMentionQuestion = userMessage.includes('@');
    const minLength = isMentionQuestion ? 120 : 80; // @ë©˜ì…˜ì˜ ê²½ìš° 120ì, ì¼ë°˜ 80ì ì´ìƒ
    
    // ì´ìƒí•œ ë‹¨ì–´/ì–´ë¯¸ íŒ¨í„´ ê°ì§€ ê°•í™”
    const hasStrangeWords = assistantMessage.match(/(ì²«ì‹¤|ë©”ëŸ¬ì¹˜|ë¦¬ìŠ¤í¬ì‹¤|ì‹œì•ˆì‹¤|ì—…ì‹¤|ì‘ì‹¤|í—˜ì‹¤|ì „ì‹¤|êµ¬ì‹¤|ì ˆì‹¤|ê°œì‹¤|ì„¤ì‹¤|ì²´ì‹¤|ê¸‰ì‹¤|ì •ì‹¤|ìš©ì‹¤|ì¡°ì‹¤|íšì‹¤|ë½ì‹¤|ì‹¤í—˜ì‹¤ì„|ì‹¤ì„|ì‹¤ì´|ì‹¤ì—|ì‹¤ì˜)/g);
    const hasStrangeEndings = assistantMessage.match(/(ê¸°ë¥¼ë³´ì•„ìš”|ë‚˜ê¸°ë„ìš”|ê±°ì˜ˆì•„ì•¼|ì•„ì—ì˜¤|ë³´ì•„ìš”|ë„ìš”|ì˜ˆì•„ì•¼|ë“¤ì–´ë³´ì…”ìš”|í’€ì–´ë³´ì…”ìš”|ì°¾ì•„ë³´ì…”ìš”|ë‚˜ë‹¤ì´|ë‹ˆë‹¤ì•„|ì—ìš”ì•„|ì£ ì•„|ë„¤ìš”ì•„|ìŠµë‹ˆë‹¤ì•„|ë‚˜ê¸°|ë„ê¸°|ì˜ˆì•„|ëŸ¬ì¹˜|ë³´ì˜¤|ì…”ìš”ì˜¤|ë‹¤ì´ì•„|ìŠµë‹ˆë‹¤ì˜¤|ë¦¬ìŠ¤í¬ì„|ë©”ëŸ¬ì¹˜ì„)/g);
    
    // ì™„ê²°ì„± ê°€ë“œ ì²´í¬ (ìŠ¤íŠ¸ë¦¬ë°) (ìì—°ìŠ¤ëŸ¬ìš´ ì™„ì„±ë„ë§Œ í™•ì¸)
    const hasCompletenessGuard = checkCompletenessGuard(assistantMessage);
    
    // ì‘ë‹µ ì™„ì„±ë„ ê²€ì‚¬ (ë§¤ìš° ì™„í™”ëœ ë²„ì „ - ëª…ë°±í•œ ì˜¤ë¥˜ë§Œ)
    const isIncompleteResponse = 
      assistantMessage.trim().length < 30 || // ë„ˆë¬´ ì§§ì€ ì‘ë‹µë§Œ (30ì ë¯¸ë§Œ)
      !hasCompletenessGuard || // ëª…ë°±íˆ ë¯¸ì™„ì„±ì¸ ì‘ë‹µë§Œ
      hasStrangeWords || hasStrangeEndings || // ì´ìƒí•œ ë‹¨ì–´/ì–´ë¯¸ íŒ¨í„´ ê°ì§€
      assistantMessage.match(/(í™œìš©í•´ì¡°|ì„¤ê³„ì¡°|ê°œë°œí•´ì¡°|ì—°êµ¬í•´ì¡°|ë„ì›€í•´ì¡°|ë”°ë¥¸ì¡°|í•˜ëŠ”ë°ì—|ì´ì—ìš”ìš”|ë‹ˆë‹¤ë‹¤)$/m);

    if (isIncompleteResponse) {
      if (hasStrangeWords) {
        console.log(`[${agentName}] ì´ìƒí•œ ë‹¨ì–´ ê°ì§€, ì‘ë‹µ ì¬ìƒì„±: ${hasStrangeWords.join(', ')}`);
      }
      if (hasStrangeEndings) {
        console.log(`[${agentName}] ì´ìƒí•œ ì–´ë¯¸ ê°ì§€, ì‘ë‹µ ì¬ìƒì„±: ${hasStrangeEndings.join(', ')}`);
      }
      if (!hasCompletenessGuard) {
        console.log(`[${agentName}] ì™„ê²°ì„± ê°€ë“œ ë¯¸í¬í•¨, ì‘ë‹µ ì¬ìƒì„±: ëª…ë°±íˆ ë¯¸ì™„ì„±ëœ ì‘ë‹µ`);
      }
      console.log(`[${agentName}] ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ ë¶ˆì™„ì „ ê°ì§€ (ê¸¸ì´: ${assistantMessage.length}/${minLength}), ì™„ì „í•œ ì‘ë‹µ ì¬ìƒì„±`);
      // ìŠ¤íŠ¸ë¦¬ë°ì´ ì•„ë‹Œ ì¼ë°˜ ì‘ë‹µìœ¼ë¡œ ì¬ìƒì„±
      const retryResponse = await openai.chat.completions.create({
        model: "gpt-4o",
        messages,
        max_tokens: maxTokens + 400,
        temperature: 0.85 + (agentSeed % 100) / 1000,
        seed: agentSeed + 1,
      });
      
      const retryMessage = retryResponse.choices[0].message.content;
      if (retryMessage && retryMessage.trim().length > assistantMessage.trim().length) {
        assistantMessage = retryMessage;
        // ì¶”ê°€ ì½˜í…ì¸ ë¥¼ ìŠ¤íŠ¸ë¦¬ë°ìœ¼ë¡œ ì „ì†¡
        const additionalContent = retryMessage.slice(fullResponse.length);
        if (additionalContent) {
          onChunk(additionalContent);
        }
      }
    }

    // ìœ ì‚¬ë„ ë¶„ì„ ë° ì¬ì‘ì„± (ê¸°ì¡´ ë¡œì§ ì¬ì‚¬ìš©)
    const similarityAnalysis = analyzeResponseSimilarity(assistantMessage, recentResponses);
    console.log(`[${agentName}] ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ ìœ ì‚¬ë„: ${similarityAnalysis.similarity.toFixed(2)}, íŒ¨í„´: ${similarityAnalysis.patterns.length}ê°œ`);
    
    if (similarityAnalysis.needsRewrite || similarityAnalysis.similarity > 0.95) {
      console.log(`[${agentName}] ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ íšì¼ì  íŒ¨í„´ ê°ì§€, ì¬ì‘ì„± ì‹¤í–‰:`, similarityAnalysis.patterns);
      
      assistantMessage = generateAlternativeResponse(
        assistantMessage,
        similarityAnalysis.patterns,
        agentName,
        agentType,
        agentSeed
      );
      console.log(`[${agentName}] ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ ì¬ì‘ì„± ì™„ë£Œ`);
    }

    // ê°•ë ¥í•œ í•„í„°ë§ ì ìš© (ë¡œì»¬ í•¨ìˆ˜ ì‚¬ìš©)
    assistantMessage = filterResponseContent(assistantMessage);
    
    // ìµœì¢… ì‘ë‹µì´ ë„ˆë¬´ ì§§ê±°ë‚˜ ì˜ë¯¸ì—†ëŠ” ê²½ìš° ë³µêµ¬ (ë” ê´€ëŒ€í•œ ì¡°ê±´)
    if (!assistantMessage || assistantMessage.trim().length < 5 || assistantMessage.trim() === '.' || assistantMessage.trim() === '') {
      // @ë©˜ì…˜ ì§ˆë¬¸ì—ëŠ” fallback ë°”ë¡œ ëŒ€ì‹  ì¬ìƒì„± ì‹œë„
      if (userMessage.includes('@')) {
        console.log(`[${agentName}] @ë©˜ì…˜ ì§ˆë¬¸ì— ëŒ€í•œ ë¹„ìƒ ì‘ë‹µ ì²˜ë¦¬`);
        assistantMessage = `ì£„ì†¡í•©ë‹ˆë‹¤. í•´ë‹¹ ì§ˆë¬¸ì— ëŒ€í•œ ìƒì„¸í•œ ë‹µë³€ì„ ì¤€ë¹„í•˜ê³  ìˆìŠµë‹ˆë‹¤. ì ì‹œ ë’¤ì— ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.`;
      } else {
        const fallbackMessages = {
          'ko': `ì•ˆë…•í•˜ì„¸ìš”! ${agentName}ì…ë‹ˆë‹¤. ë¬´ì—‡ì„ ë„ì™€ë“œë¦´ê¹Œìš”?`,
          'en': `Hello! I'm ${agentName}. How can I help you?`,
          'zh': `æ‚¨å¥½ï¼æˆ‘æ˜¯${agentName}ã€‚æœ‰ä»€ä¹ˆå¯ä»¥å¸®æ‚¨çš„å—ï¼Ÿ`,
          'vi': `Xin chÃ o! TÃ´i lÃ  ${agentName}. TÃ´i cÃ³ thá»ƒ giÃºp gÃ¬ cho báº¡n?`,
          'ja': `ã“ã‚“ã«ã¡ã¯ï¼${agentName}ã§ã™ã€‚ä½•ã‹ãŠæ‰‹ä¼ã„ã§ãã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿ`
        };
        assistantMessage = fallbackMessages[userLanguage as keyof typeof fallbackMessages] || fallbackMessages['ko'];
      }
    }

    return {
      message: cleanupResponse(assistantMessage),
      usedDocuments: availableDocuments.map(doc => doc.filename),
    };
  } catch (error) {
    console.error("Error generating streaming response:", error);
    const errorMessages = {
      'ko': "ì£„ì†¡í•©ë‹ˆë‹¤. ì‘ë‹µì„ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
      'en': "Sorry, I couldn't generate a response.",
      'zh': "æŠ±æ­‰ï¼Œæ— æ³•ç”Ÿæˆå›å¤ã€‚",
      'vi': "Xin lá»—i, khÃ´ng thá»ƒ táº¡o pháº£n há»“i.",
      'ja': "ç”³ã—è¨³ã‚ã‚Šã¾ã›ã‚“ãŒã€å¿œë‹µã‚’ç”Ÿæˆã§ãã¾ã›ã‚“ã§ã—ãŸã€‚"
    };
    const errorMessage = errorMessages[userLanguage as keyof typeof errorMessages] || errorMessages['ko'];
    return {
      message: errorMessage,
      usedDocuments: []
    };
  }
}
